###### Flask Series NOTES ############
# Part 1 - Getting Started ->
# Recreated a new environment called "flaskblog_env". Create "flaskblog" directory for the project in
# this environment and copy code from Coreys github to get started. Link ->
# https://github.com/CoreyMSchafer/code_snippets/tree/master/Python/Flask_Blog/
# \01-Getting-Started

# Install flask. ->
# # ~$ pip install flask

# Set an environment variable to the file that we want to be our flask application. 
# We have flaskblog.py as our file so we'll use FLASK_APP as the variable-->
# # ~$ export FLASK_APP=flaskblog.py
# On WINDOWS the command would be:
# # ~$ set FLASK_APP=flaskblog.py

# Run the application-->
# # ~$ flask run
# You will be prompted with an URL to copy and paste into your browser to view.
# At this point, any changes to your code will only be updated if you stop and rerun
# the flask app.
# If you have an error, put the following line of code at the top of the file --> #!/home/username/python/envs/flaskblog_env/bin/python

# Set the debugger to show saved changes to the file:
# # ~$ export FLASK_DEBUG=1


####################################################################
# General Notes:

# Part 2 - Templates -> 
# __name__ is a special variable in python that is just the name of the module.


########
# Part 3 - Forms and User Input ->
# Install flask-wtf
# # ~$ pip install flask-wtf

# In forms.py, you are specifying forms to be used but you want to protect the application with a secret key. 
# A secret key will protect against modifying cookies, cross-site requests, forgery attacks, etc. To set this,
# open the routes.py file and right below the "from" imports add the line-> app.config['SECRET_KEY'] = ''
# To generate a good random set of characters, startup your python interpreter and use the built-in secrets 
# module.
# # ~$ import secrets
# To get a big random set of characters, use the token hex method and pass in a 16 byte amount->
# # ~$ secrets.token_hex(16)
# Copy the character set and use it. (Note: in a later video this will be moved to an environment variable and 
# put in the __init__.py file)

# Created the files login.html and register.html


########
# Part 4 - Database with Flask-SQLAlchemy ->
# SQL Alchemy is a popular ORM (Object Relational Mapper) that people use for different databases. It allows
# you to access databases in an easy to use object-oriented way so that you don't have to change your code to
# query a different database; you just use a different database URL to connect with SQL ALchemy.
# This tutorial will use a SQLite DB for development and then switch to a Postgres DB for production.
# There is a regular sql alchemy package, but flask sql alchemy is a flask specific extension that provides 
# useful defaults and helpers for a flask application.
# Install flask-sqlalchemy->
# # ~$ pip install flask-sqlalchemy

# Import the module in flaskblog.py file -> from flask_sqlalchemy import SQLAlchemy
# Specify the database location in flaskblog.py file as a configuration. This location will simply be a SQL Lite 
# database on your file system -> app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
# After the location is set, create a database instance -> db = SQLAlchemy(app)
# SQL Alchemy lets you represent your database structure as classes which are also called models.
# Sepcify a double underscore method (a.k.a. dunder or magic method) to work with how the object will be printed 
# ->
# # def __repr__(self):
# # 	return f"User('{self.username}', '{self.email}', '{self.image_file}')"

# The "post" model and the "user" model are going to have a one-to-many relationship to eachother since users
# will author a post; therefore, one user can have multiple posts but a post can only have one author.
# To account for this, at the end of the "users" model, create a post attribute to be equal to the following-->
# # posts = db.relationship('Post', backref='author', lazy=True)
# backref is similar to adding another column to the post model and serves as an easy way to get the author info
# later. Lazy=True makes SQL alchemy load the data as necessary in one go.

# Create your SQL lite Database in your command terminal ->
# # ~$ python
# # >>> from flaskblog import db
# # >>> db.create_all()
# This should create a database file called "site.db" within your project directory.
# Now you want to import your models into the database ->
# # >>> from flaskblog import User, Post
# Creat an instance of a user and pass in all of the attributes that it needs. ->
# # >>> user_1 = User(username='Corey', email='C@demo.com', password='password')
# Then add the user to the db ->
# # >>> db.session.add(user_1)
# The changes have not been commited yet and are not in the database. Lets commit the changes to the database ->
# # >>> db.session.commit()

# SQL ALchemy makes it easy to query databases. If you want to query all the users ->
# # >>> User.query.all
# If you just want to get the first user, then you can access it from the list that was just returned, OR you 
# can use the "first" method that gives the very first result ->
# # >>> User.query.first()
# You can also filter the results. Let's say you want to filter by username for a list of all names of Corey ->
# # >>> User.query.filter_by(username='Corey').all()
# You can also filter by the first username without it being in a list ->
# # >>> User.query.filter_by(username='Corey').first()
# To use this query and capture it in a new variable and then display what the variable captured ->
# # >>> user = User.query.filter_by(username='Corey').first()
# # >>> user

# To access additional attributes ->
# # >>> user.id
# The above would return an auto generated id of 1

# You can also query by user ID. To fetch a user with a specific ID of 1 ->
# # >>> user = User.query.get(1)

# To see the user by posts ->
# # >>> user.posts

# To create some posts by user, you have to provide all post attributes ->
# # >>> post_1 = Post(title = 'Blog 1', content='First Post Content!', user_id=user.id)
# # >>> post_2 = Post(title = 'Blog 2', content='Second Post Content!', user_id=user.id)
# Be aware a date was not provided because the model is set to default with current UTC to populate a date/time.
# You can provide a date if you want.
# If you've provided the above info, remember you still need to add & commit the changes to the DB ->
# # >>> db.session.add(post_1)
# # >>> db.session.add(post_2)
# # >>> db.session.commit()
# To view the changes in the form of a list ->
# # >>> user.posts
# Since the info is a list of data, you can loop through posts like usual to print out ->
# # >>> for post in user.posts:
# # ...   print(post.title)
# # ...
# # Blog 1
# # Blog 2
# # >>> 

# Now get the first of the posts by querying the post table directly ->
# # >>> post = Post.query.first()
# # >>> post
# If you want the ID of the user that created the post ->
# # >>> post.user_id
# If you want more information from the user that created the post, use the backref relationship that was 
# created in the previous post model ->
# # >>> post.author

# To delete all your data to start clean again ->
# # >>> db.drop_all()
# To create the tables & database structure fresh again ->
# # >>> db.create_all()
# To query the database for all users just to see that it's clean ->
# # >>> User.query._all()
# # >>> Post.query._all()
# You should see blank [] after each query entry


########
# Part 5 - Package Structure ->
# The purpose of this video is to restructure the app to run as a package rather than as a module.
# Miguel Greenburg gave a talk at pyCon in 2016 called "Flask at Scale" that explains the reason for packaging.
# Video time @ 9:00 is where a new folder called "flaskblog" is created and all the prj files are moved to it 
# with exception of the original file called flaskblog.py (left outside the folder). 
# Then __init__.py is created @ 10:00. The and routes.py file is made @ 11:30. 
# @ 12:25 flaskblog.py is renamed to run.py. All the new files have had changes to import calls.

# @ 17:35 the new app is run ->
# # ~$ python run.py
# Follow the link to view in your browser
# Test the login page with user = admin@blog.com and password = password.

# Now, stop the app, activate python in command terminal, and re-create your database ->
# # ~$ CTRL^C
# # ~$ python
# # >>> from flaskblog import db
# # >>> from flaskblog.models import User, Post
# # >>> db.create_all() 
# Now query the new db. You should see a result of blank []. Exit out of python afterwards.
# # >>> User.query.all()
# # >>> exit()
# Now run the tree command to see the file structure. You should see sit.db added into the flaskblog folder.
# For now it is ok to have the site.db in this location because it's where our SQLite db is. Later it should
# be put outside the folder.



########
# Part 6 - User Authentication ->
# This is to learn how to add a user and authenticate them so they can log in/out and create posts.

# Need to hash passwords to protect user information if it was ever hacked. The extension bcrypt is good to use.
# # ~$ pip install flask-bcrypt

# See how it works in python by importing the class ->
# # ~$ python
# # >>> from flask_bcrypt import Bcrypt
# Create an instance of the class and pass in a temp password to hash ->
# # >>> bcrypt = Bcrypt()
# # >>> bcrypt.generate_password_hash('testing')
# This creates a password hash in bytes denoted with 'b'. If you want a string you can decode to UTF-8 by ->
# # >>> bcrypt.generate_password_hash('testing').decode('utf-8')

# Note that each time bcrypt is run, you will get a different hash. To check against original password hashes
# you need another method to see if they're equal by saving the 1st hash as a variable ->
# # >>> hashed_pw = bcrypt.generate_password_hash('testing').decode('utf-8')
# Now use the check_password method by passing in a different word other than 'testing'. The result should be
# false. ->
# # >>> bcrypt.check_password_hash(hashed_pw, 'password')
# If you pass in the correct word of 'testing', the result should be True ->
# # >>> bcrypt.check_password_hash(hashed_pw, 'testing')
# Now go add the imports and calls to the __init__.py file to initialize.

# In the routes.py file, go to the register route to fix the logic.->
# # hashed_password = bcrypt.generate_password_hash(form.password.data).decode('utf-8')
# #        user = User(username=form.username.data, email=form.email.data, password=hashed_password)
# #        db.session.add(user)
# #        db.session.commit()
# #        flash('Your account has been created! You are now able to log in', 'success')
# #        return redirect(url_for('login'))

# Run the app to test it. Username = CoreyMS, email = CoreyMSchafer@gmail.com, password = testing1
# If all works fine, shutdown the app, and go see if the db recorded the new account ->
# # ~$ python
# # >>> from flaskblog import db
# # >>> from flaskblog.models import User
# # >>> user = User.query.first() 
# # >>> user
# The result should show-> User('CoreyMS', 'CoreyMSchafer@gmail.com', 'default.jpg')
# Now look at the password. It should show a hashed string of characters ->
# # >>> user.password 

# If you go back to the routes.py file for the register code, you'll find that currently there's no logic to 
# stop a user from trying to sign up with already used credentials. If you test this by registering again, the 
# app will throw an error message screen that can be debugged. (REMEMBER to never leave production apps in debug
# mode because the error screen can give too much information to hackers!) The best fix is to create a custom 
# form function within the form.py file. The basic template of this function is as follows; customize it. ->
# # def validate_field(self, field):
# #        if True:
# #            raise ValidationError('Validation Message')

# @ 19:30. It's time to create a good login system so users can log in/out. This is easily done with the use of
# a flask extension called flask-login. ->
# # ~$ pip install flask-login
# Add the needed code to the __init__.py file ->
# # from flask_login import LoginManager
# # login_manager = LoginManager(app)
# @ 22:44 Create a function with a decorator called user loader in the models.py file. The template info of this
# code can be grabbed from the documentation of the extension. ->
# # @login_manager.user_loader
# # def load_user(user_id):
# # 	return User.query.get(int(user_id))

# @ 22:50. The extension will expect the User model to have 4 certain attributes and methods: 
# 	- Authenticated (which returns True if valid credentials were provided)
# 	- Is Active
# 	- Is Anonymous
# 	- GetID method
# Rather than add all the above methods & attributes manually, the extension provides the ability to inherit 
# them by importing a class from flask_login called UserMixin. Be sure that you are inheriting from BOTH the 
# db.Model and UserMixin so that you don't overwrite the DB model.
# @ 24:15. Now modify the login route in routes.py file. Previously the logic was to check for hard coded 
# username and password. But now we need the conditional to check for any valid credentials. So to fix, delete
# ->
# # if form.email.data == 'admin@blog.com' and form.password.data == 'password':
# #          flash('You have been logged in!', 'success')
# #          return redirect(url_for('home'))

# @ 24:46. The user will be logging in with an email, so create a query to check the db for that ->
# # user = User.query.filter_by(email=form.email.data).first()
# Then create a conditional in the query that checks simultaneously if the email exists and password verifies ->
# # 	if user and bcrypt.check_password_hash(user.password, form.password.data)
# #         login_user(user, remember=form.remember.data)
# #         return redirect(url_for('home'))
# Test the site by running it and attempting to login with non-used credentials -> C@demo.com, password
# The result should kick you back to the login page and flash the red warning flag
# Now try to log in with actual credentials -> CoreyMSchafer@gmail.com, testing1
# The result should be successful and take you to the home page.

# Currently, if a user is logged into their account, they are able to click other links and still access pages 
# as if they're not logged in. Fix the logic to prevent this and navigate a user back to their homepage by 
# importing the "current_user" variable from the flask_login extension in the routes.py file for the register & 
# login routes->
# #     if current_user.is_authenticated:
# #          return redirect(url_for('home'))

# @ 31:25. Replace the login link with a logout one when the user is logged in and allow the user to logout.
# First, in routes.py file import the logout_user function at the top of the file and at the end add logic ->
# # @app.route("/logout")
# # def logout():
# #    logout_user()
# #    return redirect(url_for('home'))
# @ 32:45 Now go to the layout.html file to create the logout link. This will use a jinja2 conditional and the
# current_user.is_authenticated function like before. Incorporate code blocks around the existing Login & 
# Register links ->
# #             {% if current_user.is_authenticated %}
# #	        <a class="nav-item nav-link" href="{{ url_for('logout') }}">Logout</a>
# #             {% else %}
# #             <a class="nav-item nav-link" href="{{ url_for('login') }}">Login</a>
# #             <a class="nav-item nav-link" href="{{ url_for('register') }}">Register</a>
# #             {% endif %}

# @ 35:08. Now you need to create a restriction on certain routes so that only the logged in user can go to
# them. In the routes.py file at the bottom, create the account route and return an account template ->
# # @app.route("/account")
# # def account():
# #     return render_template('account.html', title='Account')
# Now go to the templates directory and create a new file called "account.html". Copy/Paste the info from 
# about.html. In the layout.html, create the new account link above the logout link. Save all files and test.
# You will find that if you hit "Logout" and manually try to enter the "/Account" page you can get there but 
# the screen is blank since it doesn't know who the user is and what to display.
# @ 38:25. You only want the logged in user to access the account page. To easily fix this you can use the 
# login_required decorator from the flask_login extension. In routes.py file, import the login_required
# extension at the top of the file and then add the following line just below the account decorator. ->
# # @login_required
# Then alter the __init__.py file to tell the extension where the login route is located (line 12). Note: the
# view that you pass into the login_manager is the function name of the route which is the same thing you would
# pass into a URL_for function. ->
# # login_manager.login_view = 'login' 
# Test by manually typing in "/account", it redirects you to login and once you do, you see the user info.

# @ 40:55. The flashed message that appeared in the previous testing showed up ugly. We've been using the flash 
# categories to color other alerts. Lets fix this to the bootstrap classes category of "info" which appears 
# blue. Go to __init__.py file and add code below the last edit (line 13).

# @ 41:45. The second cleanup item is for how the page redirects after you attempt to see account info and are
# prompted to log in. Once you log in, it doesn't go to the account info, you have to explicitly click again. 
# During this moment, a query parameter called "next" was added to the URL of the page we were trying to access.
# The "next" query parameter is equal to the route that we were tryin to log into before. It looks like--
# http://127.0.0.1:53837/login?next=%2Faccount
# Use this in the login route to access that query parameter to see if it exists and then redirect the user to 
# it after log in. In the routes.py file, import the "request" extension from flask, then update the login route
# after line 61 and update the return line with a ternary conditional. Insert/Update lines. ->
# #             next_page = request.args.get('next')
# #             return redirect(next_page) if next_page else redirect(url_for("home"))
# NOTE: args is a dictionary, but you don't want to access "next" using [] and key name because this can throw 
# an error if the key doesn't exist; also the "next" parameter is going to be optional here, hence use of GET 
# method. The ternary condtional is saying redirect to "next" if the page exists, but if it returns none then 
# redirect home. Test that this works properly by manually going to "/account" page, then logout, and login.



########
# Part 7 - User Account and Profile Picture ->
# Make it so a user can update their account information and add an image to their profile picture.
# Update the account.html file with the code snippets file from Coreys github. It goes sandwiched in the code 
# block. This code includes some bootstrap classes to make things look nicer along with css style references. It
# also has hardcoded code for the user image, username, and email. Change these harcodes to what's needed. ->
# #                 <h2 class="account-heading">{{ current_user.username }}</h2>
# #                <p class="text-secondary">{{ current_user.email }}</p>
# Save Corey's default user pic into a new folder called "profile_pics" that is saved into the "static" folder. 
# Update the last two lines of code in the routes.py file ->
# #    image_file = url_for('static', filename='profile_pics/' + current_user.image_file)
# #    return render_template('account.html', title='Account', image_file=image_file)
# Update the image src link to reference the routes.py file ->
# #        <img class="rounded-circle account-img" src="{{ image_file }}">
# Test the code by going to the account page. You should see the default image with user and email.

# Update forms.py to be able to update account information on the site. It will be similar to the registration 
# form code, so copy that and paste it at the bottom to alter. Import current_user to the file too. ->
# # from flask_login import current_user
# Create conditionals in the code to only do validation checks when the user updates their info. ->
# # class UpdateAccountForm(FlaskForm):
# #     username = StringField('Username', validators=[DataRequired(), Length(min=2, max=20)])
# #     email = StringField('Email', validators=[DataRequired(), Email()])
# #     submit = SubmitField('Update')
# # 
# #     def validate_username(self, username):
# #         if username.data != current_user.username:
# #             user = User.query.filter_by(username=username.data).first()        
# #             if user:
# #                 raise ValidationError('That username is taken. Please choose a different one.')
# #     
# #     def validate_email(self, email):
# #         if email.data != current_user.email:
# #             user = User.query.filter_by(email=email.data).first()        
# #             if user:
# #                 raise ValidationError('That email is taken. Please choose a different one.')
# @ 10:00. Now import the new form into routes.py to pass it into the account template. Also create an instance
# of the form in the account route decorator section ->
# # from flaskblog.forms import RegistrationForm, LoginForm, UpdateAccountForm
# #    form = UpdateAccountForm()
# #    image_file = url_for('static', filename='profile_pics/' + current_user.image_file)
# #    return render_template('account.html', title='Account', image_file=image_file, form=form)
# @ 11:00. Next you have to get this to display in a template. Copy some code in the register.html; you're only 
# copying the div/ that holds the content-section! Paste the code into the account.html file over the comment 
# that says <-- FORM HERE -->. Alter the code to keep the username and email fields, but get rid of the entire div
# that surrounds the password related fields.Then change the legend from "Join Today" to "Account Info". 
# Remove the div tags for "content-section" so that the formatting is not used.

# @ 13:35. Fix project so that updates will be processed and this form auto inputs the existing username & 
# email. In routes.py file, add allowed messages to post to the form. Copy/Paste the GET POST methods from the 
# "login" route code into the "account" route code and add the conditionals for if the form is valid when 
# submitted. You also want to add a flash message if successful and a redirect to the account page to not allow
# the "post/get redirect pattern" that would possibly notify you that you are about to submit another post 
# request during page reload.
# # @app.route("/account", methods=['GET', 'POST'])
# # @login_required
# # def account():
# #     form = UpdateAccountForm()
# #     if form.validate_on_submit():
# #         current_user.username = form.username.data
# #         current_user.email = form.email.data
# #         db.session.commit()
# #         flash('Your account has been updated!', 'success')
# #         return redirect(url_for('account'))

# @ 16:45. Populate the current users name and email. Add elif onto the conditional last made ->
# #     elif request.method == 'GET':
# #         form.username.data = current_user.username
# #         form.email.data = current_user.email

# @ 18:00. Now is a good time to test the site and put in a 2nd user to make sure all the validations are 
# working. Using credentials of: TestUser, TestUser@demo.com, testing2.
# After creation, log in with the original user: CoreyMSchafer@gmail.com, testing1. Try to update the account 
# info using the info of the 2nd user. You should get error flags. 
# Now try entering TestUser123, TestUser123@demo.com. It should be successful. Now put back CoreyMSchafer, 
# CoreyMSchafer@gmail.com. It should be successful.

# @ 20:12. Make ability to change the profile picture. Open forms.py and import flask_wtf.file extensions that 
# will allow the type of field that this is and the validator to allow specific type uploads. ->
# # from flask_wtf.file import FileField, FileAllowed
# Scroll down the file and in the "UpdateAccountForm" class, add in between email and submit lines. ->
# #     picture = FileField('Update Profile Picture', validators=[FileAllowed(['jpg', 'png'])])
# @ 22:07. Render the field in the acount template. Open account.html and add code above </fieldset>. Note: the
# error flagging is handled differently here because the other forms are wrapped in an invalid-feedback div, 
# whereas this form is not in that div. ->
# #             <div class="form-group">
# #                 {{ form.picture.label() }}
# #                 {{ form.picture(class="form-control-file") }}
# #                 {% if form.picture.errors %}
# #                     {% for error in form.picture.errors %}
# #                         <span class="text-danger">{{ error }}</span></br>
# #                     {% endfor %}
# #                 {% endif %}
# #             </div>
# @ 24:43. Remember to add a special encoding type to the form! It must be done in order for the image data to 
# pass properly. If this is forgotten it can cause error codes that are not obvious to this problem. Go to line 
# 11 of the file and include the following as seen ->
# #     <form method="POST" action="" enctype="multipart/form-data">
# Test the site account page by trying to upload a non-jpg or png file. It should throw an error flag. Ability 
# to save an actual approved file type is not done yet. If it looks like the page isn't doing anything, make 
# sure you correctly put in the enctype!!!! Documentation and error messages aren't helpful to tell you this 
# issue.

# @ 26:45. Add the logic to the route to be able to save a profile picture if one is uploaded. Since the logic 
# for the picture is a whole chunk of code, it is best to create a new function for it just above the "/account"
# route code in the routes.py file. This function uses the secrets module to randomly code the new pic name to
# prevent similar names from having name conflict during upload. Import the secrets module at the top of the 
# routes.py file. You will set the function to use 8 bytes of hex characters. 
# @ 28:55. To make sure the file being uploaded keeps its original extension, import the os module. This 
# extension uses 2 parts: 1 to get the filename (f_name), and 1 for the .ext (f_ext).To get both, you use the 
# splitext(); but we just want the ext part, so you can "throw away a variable name" by simply using _ to start
# the code line. Some IDE's gripe about this use, so be careful. 
# @ 30:33. Now combine the random hex with the file extension to get the filename that will be saved. 
# @ 30:56. Get the full path to the directory the pic will be saved in by using an attribute called root_path.
# Line 80 in routes.py is explained @ 32:00.
# Upload a .png file to test. It should upload and update the profile picture.
# @ 35:30. Auto re-size images when they get uploaded to 125 pixels with a package called pillow. Install the
# package with pip and add it to the routes.py file -> from PIL import Image. Lines 83-88 show the added code 
# used.
# Test by re-uploading your .png and view the image. You should see it scaled down smaller. This is important to
# do because it will save tons of space and speed up the website. You should write in code that will delete old 
# pictures that a user has uploaded.


########
# Part 8 - CUD_posts ->
# Display actual posts created and have the ability to update and delete posts.
# Create a new post route with a function that will require the user to be logged in by using a login_required 
# decorator. Render a template. In routes.py add the following code ->
# # @app.route("/post/new")
# # @login_required
# # def new_post():
# #     return render_template('create_post.html', title='New Post')
# @ 1:38. Create the new template in the templates file called "create_post.html". Copy/Paste the code from the
# about.html into this new file to have a starting point. Remove the <h1> tags. The content wanted in here will 
# be a form for posting new posts. So first you need to create the form within the form.py file. @ 2:24, add. ->
# # class PostForm(FlaskForm):
# #     title = StringField('Title', validators=[DataRequired()])
# #     content = TextAreaField('Content', validators=[DataRequired()])
# #     submit = SubmitField('Post')
# Make sure to import TextAreaField at the top of the file!

# @ 4:00. Create an instance of this form in routes.py to pass in the create form in the template. At the top of
# the file, import PostForm. Add "form = PostForm()" and then pass it into the template by adding "form=form"
# into the return line. Setup the route to accept a Post/Get request. Put in a conditional to validate the form
# and handle it when it's posted. Add a flash message for when the post is created and redirect back to home 
# page. Code snippet. ->
# # @app.route("/post/new", methods=['GET', 'POST'])
# # @login_required
# # def new_post():
# #     form = PostForm()
# #     if form.validate_on_submit():
# #         flash('Your post has been created!', 'success')
# #         return redirect(url_for('home'))
# #     return render_template("create_post.html", title="New Post", form=form)

# @ 5:58. Add the form to the create post template. Open the login.html and Copy/Paste the content-section div 
# that wraps the form into the file "create_post.html". Change the Legend text to "New Post" and change the 1st 
# form-group class labels from "email" to "title". Change the 2nd form-group class labels from "password" to
# "content". Remove the entire divs containing "form-check" and "Forgot Password".

# @ 8:15. Add the link to this create_post route in the navigation bar so logged-in users can get to it easily.
# Go to the layout.html and scroll to line 36 to see the conditional that allows links to display when a current
# user is logged in. Add the new link above the Account link ->
# #             <a class="nav-item nav-link" href="{{ url_for('new_post') }}">New Post</a>
# Test all the changes in the browser.

# @ 10:08. The home page currently has dummy data. It's time to setup to save actual posts and delete old data.
# In the routes.py file on line 120(a.k.a. 107 after code deletions below), insert new code. You can use author 
# instead of userID because it's cleaner. Make sure to add and commit the post into the database. ->
# #         post = Post(title=form.title.data, content=form.content.data, author=current_user)
# #         db.session.add(post)
# #         db.session.commit()

# @ 11:55. DELETE the dummy data from the home page route at the top of the file so that the new posts show. ->
# # posts = [
# #     {
# #         "author": "John Smith",
# #         "title": "Blog Post 1",
# #         "content": "First post content",
# #         "date_posted": "September 10, 2006",
# #     },
# #     {
# #         "author": "Jane Doe",
# #         "title": "Blog Post 2",
# #         "content": "Second post content",
# #         "date_posted": "February 20, 2010",
# #     },
# # ]
# Fix the home route to query for all actual posts by adding in line 14 of code ->
# #     posts = Post.query.all()

# @ 13:57. Right now the post is displaying too much info for date/time and user. We will also put the user 
# profile pic next to the post. Currently, styles for this are in the CSS, so you just have to add the HTML to
# use them. Open home.html and alter lines 7-8 with the following ->
# #         <a class="mr-2" href="#">{{ post.author.username }}</a>
# #         <small class="text-muted">{{ post.date_posted.strftime('%Y-%m-%d') }}</small>

# @ 15:42. Display the users image next to the post; add an image tag in the content-section of home.html 
# file.->
# #   <img class="rounded-circle article-image" src="{{ url_for('static', filename='profile_pics/' + 
# # post.author.image_file) }}">
# Test the browser.

# @ 18:05. Add functionality to update or delete posts. First, make a route to a specific page for a single 
# post. In the routes.py file, create a route where the ID of a post is part of the route in the form of an 
# interger. Use the get_or_404 that will either get the post with certain ID or go to a 404 error page if it 
# does not exist.
# If the post does exist then it should render a template that returns that post. Code snippet. ->
# # @app.route("/post/<int:post_id>")
# # def post(post_id):
# #     post = Post.query.get_or_404(post_id)
# #     return render_template('post.html', title=post.title, post=post)

# @ 20:58. Create the post template with a new file called post.html. Copy/Paste the home.html code and alter it
# so that the loop block is gone and the h2 does not have a link in it; keep the class="article-title".
# Now go to the home.html file and replace the empty link to allow linking to individual posts. ->
# #     <h2><a class="article-title" href="{{ url_for('post', post_id=post.id) }}">{{ post.title }}</a></h2>
# Test the browser by logging out of the current user and creating a new post from the 2nd user, 
# TestUser@demo.com with password "testing2". You should see both posts. If you hover over a post link, you will
# see the path on the bottom left of the screen. The posts are denoted by numerical creation. If you manually 
# try to go to a non-existent post, you should be redirected to the 404 error page.

# @ 25:30. Add ability to update and delete a post. In routes.py, create a new route that's similar to the last
# one created but rename it with the word "update". You want this route to require a logged-in user, since only
# they should be able to view this area. The same functionality to get a post by ID and display a 404 error 
# should be included. Create a check conditional so that only the user that created the post can update it; if 
# the user doesn't match the post then the operation should be aborted and an error 403 is displayed. Import the
# abort extension in the flask imports. Code snippet. ->
# # @app.route("/post/<int:post_id>/update")
# # @login_required
# # def update_post(post_id):
# #     post = Post.query.get_or_404(post_id)
# #     if post.author != current_user:
# #         abort(403)
# #     form = PostForm()
# #     return render_template("create_post.html", title="Update Post", form=form)
# Now test this code by logging out and back in as the 1st user, then click on the 2nd post made by another user
# and manually try to update it by adding "/update" at the end of the browser nav bar link. It should show you 
# the forbidden error. If you go back to the home page and try to update the post that belongs to this user, it
# should take you to the "New Post" form. The issue here is that you want the original post data to show along 
# with this, as well as the word "New" in the legend be changed to "Update". Fix this by adding a legend value 
# that is passed into each template. This will also be updated in the "New Post" route too!
# @ 30:25. Now you will display the legend within the create_post.html template. Open the file and add {{}} ->
# #             <legend class="border-bottom mb-4">{{ legend }}</legend>
# Go back to the routes.py file and add code after line 128 in the "update" route section. ->
# #     form.title.data = post.title
# #     form.content.data = post.content

# @31:36. Add the logic to update the post if the form validates. Set up the "Update" route to accept POST 
# requests that forms submit to. Include the conditional that will allow update upon validation for the title 
# and content. Commit to the database. (Note: you don't need to "add" to the database here because it already is
# in the database; you're just updating the info this time). You will add a flash message for successful update 
# and redirect to the post ID of the current post. Code snippet. ->
# #     if form.validate_on_submit():
# #         post.title = form.title.data
# #         post.content = form.content.data
# #         db.session.commit()
# #         flash('Your post has been updated!', 'success')
# #         return redirect(url_for('post', post_id=post.id))

# @ 33:35. Put the sending of form data (after line 136) in it's own conditional to populate when it's a GET 
# request. Use elif.
# Test the browser by trying to "update" a post (remember to enter the url manually for now). You should see the
# changes of "Update" in the legend and the previous post info populated.

# @ 35:07. Create the ability to delete a post for a user and add the links for delete and update to the 
# template. A double confirmation of deleting a post will be made to make it hard for a user to delete a post on
# accident. Open the post.html file and create code blocks at the end of the article-metadata div that have a 
# conditional that will only show the links if the post belongs to the current user. Put the link codes inside 
# the code block. The "Update" link will be an anchor tag style but the "Delete" link will be a button. The 
# "Delete" button will use a bootstrap modal, hence why it's a link. The modal code is directly from the 
# bootstrap website. Link-> https://getbootstrap.com/docs/4.0/components/modal/
# Copy the toggle and target portion of the code into the last part of the delete button class. ->
# # <button type="button" class="btn btn-danger btn-sm m-1" data-toggle="modal" data-\
# # target="#deleteModal">Delete</button>
# Then add the rest of the modal code at the very end of the article tag, still within the code block ending. 
# Change the "exampleModal" label to "deleteModal". Test the browser for these changes by going to a post owned
# by the logged user. You should see the Update and Delete links and a pop-up if you hit Delete.

# @ 41:14. Fix the margin of the Update link with mt-1 & mb-1 (margin top and margin bottom)->
# # <a class="btn btn-secondary btn-sm mt-1 mb-1" href="{{ url_for('update_post', post_id=post.id)\
# # }}">Update</a>
# Alter the modal pop-up by changing the "Modal title" to "Delete Post?" and deleting the modal-body div.
# Replace the button to save changes with a form with an action to submit. ->
# #                 <form action="{{ url_for('delete_post', post_id=post.id) }}" method="POST">
# #                     <input class="btn btn-danger" type="submit" value="Delete">
# #                 </form>

# @ 44:05. Create the delete_post route that was just coded above. This will be similar to the Update route.
# # @app.route("/post/<int:post_id>/delete", methods=["POST"])
# # @login_required
# # def delete_post(post_id):
# #     post = Post.query.get_or_404(post_id)
# #     if post.author != current_user:
# #         abort(403)
# #     db.session.delete(post)
# #     db.session.commit()
# #     flash("Your post has been deleted!", "success")
# #     return redirect(url_for("home"))
# Test your code!


########
# Part 9 - Pagination ->
# Pagination so you aren't pulling down too many posts at once and sort posts from newest to oldest. You want to
# only show a short amount of posts and have a link at the bottom to get to the other posts.
# Use Corey's JSON file to input the 25 different posts he made to work with the building of this code.
# Link-> https://github.com/CoreyMSchafer/code_snippets/blob/master/Python/Flask_Blog/snippets/posts.json
# Or you can just make at least 10 of your own posts. Once done, run the info in CLI to see how it looks ->
# # ~$ python
# # >>> from flaskblog.models import Post
# # >>> posts = Post.query.all()
# # >>> for post in posts:
# # ...   print(post)
# # ...
# You should see all the posts listed. Now see how it looks if you use a Post.query.paginate query.->
# # >>> posts = Post.query.paginate()
# # >>> posts
# # <flask_sqlalchemy.Pagination object at 0x10bde5cc0>
# The above means this is a pagination object. Let's see what attributes & methods this object has ->
# # dir(posts)
# The list given by the command shows it's an object that gives information about the current page you're on,
# how many posts there are per page,etc.. Look at how many posts per page there are (default is 20) ->
# # >>> posts.per_page
# Look at the current page (it should be 1) ->
# # >>> posts.page
# Now print out the individual items like before (The amount you entered should display) ->
# # >>> for post in posts.items:
# # ...   print(post)
# # ...
# @ 4:25. To see posts beyond the first page of items, you can specify the page number. (Only if you have beyond
# 20 items, which is the default. Otherwise you'll get a python error) ->
# # >>> posts = Post.query.paginate(page=2)
# # >>> for post in posts.items:
# # ...   print(post)
# # ...
# @ 5:15. If the default of 20 items is too much, then you can specify fewer per page to view. ->
# # >>> posts = Post.query.paginate(per_page=5)
# # >>> posts.page
# # 1
# # >>> for post in posts.items:
# # ...   print(post)
# # ...
# Now re-run the query specifying 5 items per page on page 2. Then loop thru again & print to see the items ->
# # >>> posts = Post.query.paginate(per_page=5, page=2)
# # >>> posts.page
# # 2
# # >>> for post in posts.items:
# # ...   print(post)
# # ...

# @ 6:20. To see the total number of posts in all of the pages, use the total attribute. ->
# # >>> posts.total
# # 10

# @ 6:40. In routes.py file, in line 14, alter the code to use paginate and only allow 5 items per page ->
# #    posts = Post.query.paginate(per_page=5)

# @ 7:19. To grab the page that you want, you pass a query parameter in the URL. Set the default page=1 and 
# set a type=int to ensure that an error will be thrown if someone tries to pass something other than a number.->
# #     page = requests.args.get('page', 1, type=int)
# #     posts = Post.query.paginate(page=page, per_page=5)
# Now you have to go and update the home.html template to accomodate for now having a pagination object. You
# have to add .items ->
# # {% for post in posts.items %}
# Test in browser. You should only see 5 posts on the page. There are no links yet, but you can manually pass in
# a page number to view via the URL bar; add "?page=2" to the very end of the existing URL. You should see the 
# next 5 posts of the set.

# @ 9:35. Now update the template to see the links to the other pages. You want to temporarily change line 15 in
# the routes.py file to a small number per_page while working on the links because you want to initially have a 
# lot of links to display for future post growth. Test this using python in CLI to see what this will look like.
# ->
# # ~$ python
# # >>> from flaskblog.models import Post
# # >>> posts = Post.query.paginate(page=6, per_page=1)
# # >>> for page in posts.iter_pages():
# # ...   print(page)
# # ...
# # 1
# # 2
# # None
# # 4
# # 5
# # 6
# # 7
# # 8
# # 9
# # 10
# # >>>
# The None in the list is representative of a marker that indicates there's more pages at the beginning and the
# end as well as what the current page is.

# @ 12:06. In home.html template, open a for loop to loop over the pages. None values will be displayed as 
# ellipses. Make an if else statement to link to the page->
# # {% for page_num in posts.iter_pages() %}
# #     {% if page_num %}
# #         <a class="btn btn-outline-info mb-4" href="{{ url_for('home', page=page_num) }}">{{ page_num }}</a>
# # {% else %}
# #     ...
# # {% endif %}
# # {% endfor %}
# Test your browser.

# @ 15:30. Customize the amount of links showing and style the page to show what page you're on. Pass in a few 
# args to iter pages. Code snippet is as follows->
# # {% for page_num in posts.iter_pages(left_edge=1, right_edge=1, left_current=1, right_current=2) %}
# # 	{% if page_num %}
# # 		{% if posts.page == page_num %}
# # 			<a class="btn btn-info mb-4" href="{{ url_for('home', page=page_num) }}">{{ page_num}}\
# # </a>
# # 		{% else %}
# # 			<a class="btn btn-outline-info mb-4" href="{{ url_for('home', page=page_num) }}">\
# # 			{{ page_num }}</a>
# # 		{% endif %}
# # 	{% else %}
# # 	...
# # 	{% endif %}
# # {% endfor %}

# @18:45. Change the posts per page back to a higher number so that things display correctly. On line 15 of  the
# routes.py file.
# @ 19:20. Change the current viewing order of the posts to have the oldest post at the bottom and newest at the 
# top. In the routes.py file on line 15, incoroporate the order_by function. ->
# #     posts = Post.query.order_by(Post.date_posted.desc()).paginate(page=page, per_page=5)

# @ 21:23. Currently, the username of each post displays as a link, but it doesn't go anywhere if clicked. Fix
# this by building a route that will display only the posts from a particular user on clicked link. In routes.py
# copy/paste the home route at the bottom of the file to alter. NOTE: a "\" is used in code to split a long 
# line. Code Snippet. ->
# # @app.route("/user/<string:username>")
# # def user_posts(username):
# #     page = request.args.get('page', 1, type=int)
# #     user = User.query.filter_by(username=username).first_or_404()
# #     posts = Post.query.filter_by(author=user)\
# #         .order_by(Post.date_posted.desc())\
# #         .paginate(page=page, per_page=5)
# #     return render_template("user_posts.html", posts=posts, user=user)

# @ 24:40. In the template folder, create a new file called "user_posts.html" Copy/Paste home.html info into it.
# On line 3 of this template, it will specify a user variable that will display the total number of posts over 
# the paginated links. Code Snippet. ->
# #     <h1 class="mb-3">Posts by {{ user.username }} ({{ posts.total }})</h1>
# The for loop will mostly stay the same, with exception to the user post route href that currently displays 
# "#".->
# # {{ url_for('user_posts', username=post.author.username) }}
# Update this link in the home.html & post.html files! Sub-templates will be later made to solve this issue of
# having to paste the same info in multiple areas.

# @ 28:05. Got back to the user_posts.html and fix the pagination links at the bottom. These should not link to
# the home page. It should link to the user_posts route. Code Snippet. ->
# # <a class="btn btn-info mb-4"
# #     href="{{ url_for('user_posts', username=user.username, page=page_num) }}">{{ page_num }}</a>
# # {% else %}
# # <a class="btn btn-outline-info mb-4"
# #     href="{{ url_for('user_posts', username=user.username, page=page_num) }}">{{ page_num }}</a>
# Test in browser.


########
# Part 10 - Email_Password_Reset ->
# Use email to allow a user to reset their passwords. This will generate a secure time sensitive token to ensure
# only that specific user can reset their password, and then send an email with that reset information. 
# This uses a package called itsdangerous. To test this in CLI for example, import a specific Serializer and 
# pass in a secret key and an expiration time of 30 seconds. Then generate a token with the dumps method and 
# send a payload that is a dictionary; this will just be equal to the user_id. Also decode this in utf-8 
# otherwise it will be in bytes format. Look at the token and you will see it's a long random string of 
# characters. To check if this is a valid token, use the loads method and pass in the token. Wait 30 seconds, 
# try to look again and you will see it's expired.->
# # >>> python
# # >>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
# # >>> s = Serializer('secret', 30)
# # >>> token = s.dumps({'user_id': 1}).decode('utf-8')
# # >>> token
# # 'eyJhbGciOiJIUzUxMiIsImlhdCI6MTU3Mzk2MzQ1MCwiZXhwIjoxNTczOTYzNDgwfQ.eyJ1c2VyX2lkIjoxfQ.a0NbIAsZxfa25IJ9Z\
# # OmbZ3zZCQTi_FyTnqA5-bqa5X_iY-ow3BJjIxdLhB1gy51tRjD1-OLVqQqRl4Ih21_Czg'
# # >>> s.loads(token)
# # 
# # >>> s.loads(token)
# # Traceback (most recent call last):
# #   File "<stdin>", line 1, in <module>
# #   File "/home/username/miniconda3/envs/flaskblog_env/lib/python3.7/site-packages/itsdangerous/jws.py", line 
# # \205, in loads date_signed=self.get_issue_date(header), itsdangerous.exc.SignatureExpired: Signature expired
# # >>>

# @ 3:00. Open the database models.py and add some methods to the user model that creates and validates tokens. # Import the same classes used in the CLI example into the top of the file and include "app". Then within the 
# User model, create a method called get_reset_token and pass in an instance of the user that expires in 30min.
# Within this new method, create a Serializer object and pass in a secret key with the expiration time and 
# return a token created from the serailzer. The payload will be the instance of the user and be decoded to 
# utf-8. Code snippet. ->
# #     def get_reset_token(self, expires_sec=1800):
# #         s = Serializer(app.config['SECRET_KEY'], expires_sec)
# #         return s.dumps({'user_id': self.id}).decode('utf-8')

# @ 6:07 Create a second method that verifies a token: Take a token as an argument, then create a serializer 
# object with the secret key, however, this time it will not need to pass in the expires_sec. Because it's 
# possible to get an exception with an invalid or expired token, put this code inside a Try/Except block: You're
# trying to get the user_id by loading that token and getting it out of the payload that was passed in. If that
# doesn't run smoothly then you will catch the exception and return None from the method. If you are able to get
# the user_id without throwing an exception then you just want to return the user with that ID. Code snippet. ->
# # 	@staticmethod
# #     def verify_reset_token(token):
# #         s = Serializer(app.config['SECRET_KEY'])
# #         try:
# #             user_id = s.loads(token)['user_id']
# #         except:
# #             return None
# #         return User.query.get(user_id)
# @ 7:50. Notice the above method doesn't do anything with the instance of this user (it never uses the "self"
# variable). This is because when you have a method like this, you need to tell Python that this is a static 
# method. This is done with a simple decorator @staticmethod, which will tell python not to expect the "self"
# parameter as an argument; it will only be accepting the token as an argument.

# @ 8:25. Now create two new forms for the routes so that the user can send an email and create a reset link. 
# Open the forms.py file. The first form will be RequestResetForm. You want to validate that an account exists
# for the email address so the code will be similar to the registration form. Code Snippet. ->
# # class RequestResetForm(FlaskForm)
# #     email = StringField("Email", validators=[DataRequired(), Email()])
# #     submit = SubmitField("Request Password Reset")
# # 
# #     def validate_email(self, email):
# #         user = User.query.filter_by(email=email.data).first()
# #         if user is None:
# #             raise ValidationError("No account exists with that email. You must register first.")  

# @ 10:45. The second form will be for when the password is reset. There will be two password fields to type the
# new password and then confirm the password. Again, these are similar to the registration form. Code Snippet ->
# # class ResetPasswordForm(FlaskForm):
# #     password = PasswordField("Password", validators=[DataRequired(), Length(min=8)])
# #     confirm_password = PasswordField("Confirm Password", validators=[DataRequired(), EqualTo("password")])
# #     submit = SubmitField("Reset Password")

# @ 11:52. Create the routes and templates to handle the forms. The first route will be where the user will 
# request to reset their password. In the routes.py file, import the two forms just created. Copy/Paste the 
# first two lines of an existing route to start (like the /post/new route) and alter it. Put the same check in
# this route that is in the Login route to make sure a user is logged out before they reset their password. Now
# create the form and refer to a new template called "reset_request.html". Code snippet. ->
# # @app.route("/reset_password", methods=["GET", "POST"])
# # def reset_request():
# #     if current_user.is_authenticated:
# #         return redirect(url_for("home"))
# #     form = RequestResetForm()
# #     return render_template("reset_request.html", title="Reset Password", form=form)

# @ 14:56. Now go create the new template where the user will request to reset their password, called 
# reset_request.html and copy/paste the code from the login.html file to start. Get rid of the form-group for 
# the password, the div for form-check, the section of Forgot Password, and the div for Need an Account.

# @ 16:44. Now create the route where the user will actually reset their password. To make sure it is actually 
# the user, you need to make sure that the token and email given are active. You'll get the token from the URL 
# that was sent and know that it's them when they navigate to this route. Remember that in the models.py file 
# for the verify_reset_token, it just takes in a token as an argument and if it is valid then it'll return the 
# user with that user ID. User ID was the payload that was passed in to the initial token. Put in a conditional
# in case the token is either invalid or expired. It should flash a warning message with the error. If the token
# is valid then it should redirect to the "reset_token.html" template. Code snippet. ->
# # @app.route("/reset_password/<token>", methods=["GET", "POST"])
# # def reset_token(token):
# #     if current_user.is_authenticated:
# #         return redirect(url_for("home"))
# #     user = User.verify_reset_token(token)
# #     if user is None:
# #         flash('That is an invalid or expired token', 'warning')
# #         return redirect(url_for('reset_request'))
# #     form = ResetPasswordForm()
# #     return render_template("reset_token.html", title="Reset Password", form=form)

# @ 20:47. Now create the template for the user to actually reset their password. It will be similar to the
# reset_request.html so copy/paste that in a new file called reset_token.html and alter it. Change all the words
# that say "email" to "password". Copy the entire form-group and paste it below; then change the "password" to
# "confirm_password".

# @ 22:04. In routes.py, go add a validate upon submit conditional to handle the forms being submitted. This 
# change will be done right after the line of code that creates the form. The code will query to grab the first
# user with that email. Then use the "send_reset_email" function (seperately created for the sending of an email
# and with the logic temporarily using "pass" to be fixed later) that passes in the user, sends a flash message 
# with a class of "info" to notify that an email has been sent, and redirects back to the login page. Code 
# Snippet ->
# #     if form.validate_on_submit():
# #         user = User.query.filter_by(email=form.email.data).first()
# #         send_reset_email(user)
# #         flash('An email has been sent with instructions to reset your password', 'info')
# #         return redirect(url_for('login'))

# @ 24:33. Fill out the logic for the "send_reset_email" function to use the flask mail extension. Install the 
# ext first with ->
# # ~$ pip install flask-mail

# @ 25:00. Go to the __init__.py file and import the extension and set some constants so the app can know how to 
# send mail. You'll need a mail server, mail port, specification to use TLS, your actual email username & 
# password. Then initialize the extension. (Remember that you're using an environment variable to handle 
# sensitive information, such as your email password, so it won't be public.) Code Snippet. ->
# # app.config["MAIL_SERVER"] = "smtp.googlemail.com"
# # app.config["MAIL_PORT"] = 587
# # app.config["MAIL_USE_TLS"] = True
# # app.config["MAIL_USERNAME"] = os.environ.get("EMAIL_USER")
# # app.config["MAIL_PASSWORD"] = os.environ.get("EMAIL_PASS")
# # mail = Mail(app)

# SIDE NOTE: To setup the environment variable in Linux, navigate in CLI to your home directory and alter the 
# .bashrc at the top of the file with your real credentials relating to the variables being used. Be sure to
# replace "yourEmail" and "yourPassword" with your actual credentials. Then source the file to activate it.->
# # ~$ cd ~
# # ~$ nano .bashrc
# # export EMAIL_USER="yourEmail"
# # export EMAIL_PASS="yourPassword"
# # Ctrl + x
# # y
# # Enter
# # ~$ source ~/.bashrc

# @ 28:08. Open the routes.py file. Import the Mail extension and Message class to be able to send a message.
# Now fix the logic in the "send_reset_email" function. Get the token using the method added earlier in 
# models.py, "get_reset_token". Then sen the email with the URL that has the reset token by using the message 
# class. Be careful not to spoof a sender, because if you pretend to be somebody that you're not you'll end up 
# in the spam folder; so use something coming from your domain. Then pass in the recipient. For the body of the 
# message, use a multi-line F string (Note: Don't use tabs in the message or they will appear!). The F string 
# will pass in the value for "url_for" with the "reset_token route", and have the token=token, and use 
# _external=True to get an absolute URL rather than a relative URL because you need the link in the email to 
# have the full domain. Code snippet ->
# # def send_reset_email(user):
# #     token = user.get_reset_token()
# #     msg = Message("Password Reset Request", sender="noreply@demo.com", recipients=[user.email])
# #     msg.body = f"""To reset your password, visit the following link: 
# # {url_for('reset_token', token=token, _external=True)}
# #         
# # If you did not make this request then ignore this email and no changes will be made.
# # """

# @ 33:30. Now you need to handle the form submission when a user actually changes their password. This will be
# similar to the register route. Go to that section and copy the Validate_on_submit conditional code. Paste it 
# into the reset_token route below where the form = ResetPasswordForm() line of code. Delete the line of code 
# for the user because it's already up above. Replace the db.session for adding with user.password =
# hashed_password. Then update the flash message. Code snippet. ->
# #     if form.validate_on_submit():
# #         hashed_password = bcrypt.generate_password_hash(form.password.data).decode("utf-8")
# #         user.password = hashed_password
# #         db.session.commit()
# #         flash("Your password has been updated! You are now able to log in", "success")
# #         return redirect(url_for("login"))

# @ 35:28. Add a link to the reset page in the application. Open the login.html template and scroll to the 
# bottom. Incorporate the actual link. Code snippet. ->
# #         <a href="{{ url_for('reset_request') }}">Forgot Password?</a>
# Also relocate this link to be inside the div tags above so that it will appear next to the login button.

# @ 38:18. There is a problem with the code in routes.py. The code to send an email is missing. Include it now 
# in the "send_reset_email" routes area. Code snippet. ->
# #     mail.send(msg) 

# Test in browser. REMEMBER that the sender email address on line 181 of the routes.py file must be updated to 
# your actual sending address for your final production code!!!!! Also make sure you have a valid user email to 
# test.


########
# Part 11 - Blueprints and Configuration ->
# Restructuring the application files and learn how to use flash blueprints. Configuration variables will be 
# moved into their own file. Creation of the application will be it's own function; this allows for different 
# instances of the application which lets you have one application for testing and one for production (called an
# Application Factory).
# @ 1:30. To create a blueprint you begin by creating a new package in the application that is named after the
# functionality that it will contain. For instance, to make a blueprint for users and author an authentication 
# functionality, make a directory called "users" in the flaskblog directory. At this point, also make a 
# directory for "posts" and one for miscellaneous items called "main". In order to tell python that these new 
# directories are packages, each directory needs to have a "__init__.py file, even if the file is blank with no 
# code in it. 

# @ 3:31. Each directory will also need it's own routes.py file too; this file will only contain the routes that 
# pertain to that functionality.

# @ 4:08. The "users" & "posts" directories will need their own forms.py file. There are some functions within 
# the "flaskblog/routes.py" directory that should be split out as well. They will go in the "users/utils.py" 
# file. Now open the "users/routes.py" file and import the blueprint class from flask, then create an instance 
# (similar to creating a flask instance). You will no longer be using the global app variable to create the 
# routes. Instead, routes will be created specifically for this users blueprint and then register these with the
# application at a later time. Code Snippet. ->
# # from flask import Blueprint
# # 
# # users = Blueprint("users", __name__)

# @ 6:14. Refer to "flaskblog/routes.py" and cut out all that has to do with users (the register, login, logout,
# account, user_posts, reset_password, and reset_password/<token> routes). Paste these into the new 
# "users/routes.py" file. 

# Back in "flaskblog/routes.py", cut the functions to save_picture and send_reset_email to paste them into the 
# "users/util.py" file.

# @ 8:18. In the "users/routes.py" file, change all instances of "@app.route" to "@users.route" to stop using 
# the global app variable to create the routes.

# @ 9:02. The same process that was done for the "users" directory will now be done for the "posts" directory. 
# Copy/Paste the 1st two lines of code from the "users/routes.py" file into the "posts/routes.py" file and 
# change the 2nd line accordingly for blueprint posts. Go back into"flaskblog/routes.py" and cut out all the 
# routes that pertain to posts. Then change all instances of "@app.route" to "@posts.route" to stop using the 
# global app variable to create the routes. Repeat this same process for the "main/route.py" file where you will
# be putting the home and about routes.

# @ 11:39. Split up the "flaskblog/forms.py" file starting with putting everything pertaining to users & 
# authentication into the "users/forms.py" file (the Registration, Login, UpdateAccount, RequestReset, 
# ResetPassword). The PostForm will be the only form in the "posts/forms.py" file.

# @ 12:56. Fix the imports at the top of the files. Use the provided code snippets at the following link or use 
# your code editor feature to tell you what is missing. Link -> 
# https://github.com/CoreyMSchafer/code_snippets/blob/master/Python/Flask_Blog/snippets/blueprint_imports.txt

# @ 15:43. Note that when you change around files, you have to be careful about bringing your imports in. As 
# example, look at "users/routes.py" file and notice that "from flaskblog.forms import" is now "from 
# flaskblog.users.forms import".

# @ 16:35. Delete the old "routes.py" and "forms.py" in the main flaskblog directory. Then open the applications
# __init__.py file and alter the last line of code that imports the routes to instead import the blueprint 
# objects from each of the packages and register them with the route. Code Snippet. ->
# # from flaskblog.user.routes import users
# # from flaskblog.posts.routes import posts
# # from flaskblog.main.routes import main
# # 
# # app.register_blueprint(users)
# # app.register_blueprint(posts)
# # app.register_blueprint(main)

# @ 19:07. Now you need to change all the url_for functions that link to all the routes, to be the URL for the 
# relative blueprints. It now needs to be the blueprint name followed by the function name. Code Snippet.->
# # url_for("main.home")
# This needs to be changed for all url_for functions that redirect to a route from the users, posts, or main 
# packages.

# @ 22:33. Another change that is not obvious is the login_view in the __init__.py file it needs to have the
# Blueprint specified before login. ->
# # login_manager.login_view = "users.login"
# This should be the last of the changes for now. Test in your browser. All should route accordingly.

# @ 24:40. Make the application easier to test by putting the configuration values of the application into their 
# own file and move the creation of the application into a function. This enables you to create instances of the
# app with different configurations.

# @ 25:00. Move all the app.config code lines from the "flaskblog/__init__.py" file into their own file called
# config.py that will be located in the flaskblog directory. They will be put inside a class Config: and make 
# them constant variables with the same names as the keys; so remove the app.config[] specs from the lines and 
# the "" from the new variables.

# @ 26:50. As best practice, it's best to keep secret information out of the source code; such as the SECRET_KEY
# and SQLALCHEMY_DATABASE_URI. Convert those to environment variables. Code Snippet. ->
# # import os
# # 
# # class Config:
# #       SECRET_KEY = os.environ.get("SECRET_KEY")
# #       SQLALCHEMY_DATABASE_URI = os.environ.get("SQLALCHEMY_DATABASE_URI")
# #       MAIL_SERVER = "smtp.googlemail.com"
# #       MAIL_PORT = 587
# #       MAIL_USE_TLS = True
# #       MAIL_USERNAME = os.environ.get("EMAIL_USER")
# #       MAIL_PASSWORD = os.environ.get("EMAIL_PASS")

# @ 29:45. In the "flaskblog/__init__.py" file, you need to tell the app to use the values set in the config.py
# file by using the app.config.from_object() method. First import it at the top of the file and then include the
# app variable right below the creation of the flask instance. Make sure to delete th os import since it's not 
# used now.

# Test in browser.
# @ 31:25. Move the creation of the app into a function to make it easier to run multiple instances of the app 
# for testing and configuration. In the __init__.py file, create a function called "create_app()" that will take 
# an argument for the configuration object you want used for the application; this will be set to the config 
# class. Next, move the code lines that create the app into the function while leaving the extensions being used
# to stay outside the function. Although, you'll still want to initialize the extensions inside of the function.
# The reason for this is explained in the Flask docs. It basically says this is so the extension object does not
# initially get bound to the application therefore allowing a single extension object to be used for multiple 
# apps. Code Snippet. ->
# # def create_app(config_class=Config):
# #     app = Flask(__name__)
# #     app.config.from_object(Config)
# # 
# #     from flaskblog.users.routes import users
# #     from flaskblog.posts.routes import posts
# #     from flaskblog.main.routes import main
# #     app.register_blueprint(users)
# #     app.register_blueprint(posts)
# #     app.register_blueprint(main)

# @ 33:27. You initialize the extensions at the top of the file without the app variable; so delete "app" from 
# each. Then use the init_app() method to pass the application to all of the extensions by copying the four 
# extension names into the function and passing in "app". Code Snippet. ->
# #     db.init_app(app)
# #     bcrypt.init_app(app)
# #     login_manager.init_app(app)
# #     mail.init_app(app)

# @ 34:10. At the bottom of the function, return the app.

# @ 34:20. Doing all this has now created the issue that there is no longer an app variable that can be imported
# from the flaskblog package. The fix is to find/replace all instances of the app variable throughout the 
# package with an import called "current_app".

# @ 37:28. Look at run.py file and import the create_app function rather than just app. Then you'll want to add 
# code to actually create the app. Code Snippet. ->
# # app = create_app()
# The code could have passed in a configuration as an argument, but remember it's using the config class that 
# was created earlier as it's default. So this is why you don't have to pass anything in.
# Test in browser. All should still work fine.


########
# Part 12 - Custom Error Pages ->
# The current error pages of the app are for 404 = not found and 403 = forbidden. We need 500 = general server 
# error.
# @ 1:17. Create a new blueprint package called "errors" in the application (flaskblog) directory. Remember that
# all package directories need a __init__.py file even if it is a blank file. 

# @ 2:03. Create a new file called "errors/handlers.py", import the blueprint class, and put code similar to a
# routes.py file with routes that have functions for the three errors needed. Each error route will have a 
# decorator and use .app_errorhandler(). Then they will have a function that takes in "error" parameter and 
# returns a render template function. Code Snippet. ->
# # from flask import Blueprint, render_template
# # 
# # errors = Blueprint("errors", __name__)
# # 
# # @errors.app_errorhandler(404)
# # def error_404(error):
# #     return render_template("errors/404.html"), 404
# # 
# # 
# # @errors.app_errorhandler(403)
# # def error_403(error):
# #     return render_template("errors/403.html"), 403
# # 
# # 
# # @errors.app_errorhandler(500)
# # def error_500(error):
# #     return render_template("errors/500.html"), 500

# @ 5:12. Now there are app error handlers for three different page error responses. The reason that you use
# app_errorhandler() over errorhandler() is because you want the handler to work accross the entire application. 

# @ 5:42. Within the "templates" directory, create a new sub-directory called "errors". Within the new sub-
# directory create three new template html files for 403, 404, and 500. For each new file you need to extend the
# layout and insert html code in code blocks {%%}. 404.html Code Snippet. ->
# # {% extends "layout.html" %}
# # {% block content %}
# #     <div class="content-section">
# #         <h1>Oops. Page Not Found (404)</h1>
# #         <p>That page does not exist. Try a different location.</p>
# #     </div>
# # {% endblock content %}

# @ 9:00. Now you need to register the templates with the application in the flaskblog/__init__.py file. Code
# Snippet. ->
# # from flaskblog.errors.handlers import errors
# # app.register_blueprint(errors)

# Test in browser. Manually try to go to a page that doesn't exist by adding "/test" at the end of the browser 
# link. You should see the 404 error. Manually try to "update" a post that doesn't belong to the user by adding 
# "/update" at the end of the browser link. You should see the 403 error.

########
# Part 13 - Deploy to a Linux Server ->
# Explore different options to deploy to a server but in the end deploy using nginx and g unicorn. 

# @ 3:45. Using Linode.com you will create a server from scratch. Click on the upper left corner button that 
# says "Create" and then on "Linode" for their server. Make the following choices:
# OS system = Ubuntu
# Region = Dallas TX
# Plan = Nanode 1GB (since it's the cheapest)
# Label = "flask-server"
# Root Password = ThisIsATest (as example but make it something strong that you'll remember. You'll need it!)
# Optional Add-ons = Backups (recommended for production servers, but not needed for now)

# Once you click on "Create" button you will have to wait will the new server gets provisioned and booted up.
# @ 6:11. Click on the new server and navigate to the Networking tab. Copy the SSH Access command and paste it 
# into your CLI to login to the server. You'll want to use bash on a windows machine to follow along easier. The
# SSH access will look similar to...ssh root@45.33.123.214. (The address shown is example; your ip address will 
# be different!)


# SIDE NOTE: If you're using Ubuntu 18.04, it does not come enabled with SSH. 
# First, check if an SSH server has already been installed. ->
# # ~$ ssh localhost
# If you see the message "ssh: connect to host localhost port 22: Connection refused", you will have to go 
# through the SSH installation process. Begin by updating the package repository cache. ->
# # ~$ sudo apt-get update
# Next, install the OpenSSH software package ->
# # ~$ sudo apt-get install openssh-server
# I specifically had to do ->
# # ~$ sudo apt-get install ssh
# Verify the installation was successful and SSH is running ->
# # ~$ sudo service ssh status
# You may have to start the service with ->
# # ~$ sudo service ssh start


# @ 7:44. When you enter the SSH Access command it will ask you if you are sure you want to continue. Type "yes" 
# and hit enter. Use two different CLI window sessions to help work on this so you don't have to be switching 
# back & forth.

# @ 9:10. Once logged in, you'll have a barebones Ubuntu web server that needs to be setup. First, update the 
# software. This will take a while and ask several times for your input of 'y' to continue. ->
# # ~$ apt update && apt upgrade

# @ 9:49. Now you want to set a hostname on the machine. ->
# # ~$ hostnamectl set-hostname flask-server
# Check that the hostname is set. It should show flask-server. ->
# # ~$ hostname 
# # flask-server

# @ 10:12. Now you need to set the hostname in the hosts file. ->
# # ~$ nano /etc/hosts
# You'll paste the hostname of the new Ubuntu server SSH Access below the 127.0.0.1 address of the local 
# computer. (The ip address shown below is example; your address will be different!) ->
# 45.33.123.214 flask-server

# @ 11:16. Now you'll add a limited user to the machine. You are currently logged in as the root user, and this
# user has unlimited privileges and can execute any command. It's best to add a limited user because it's safer 
# than running everything as the root user. Add the user with the following command using your own 
# 'remote_username'. Code Snippet. ->
# # ~$ adduser remote_username
# It will prompt you to enter a password twice and then to enter some basic info about the user. The basic info 
# is optional so you can choose to hit 'Enter' through it and then confirm with 'y' at the end.

# @ 12:39. Add the new 'remote_user' to the sudo group so they can run admin commands too. ->
# # ~$ adduser remote_user sudo
# Logout and then back in as the new 'remote_user' so you won't be logged in as root user longer than needed.->
# # ~$ exit
# # logout
# # Connection to 'server_ip_address' closed.

# @ 13:18. Log back in as the new 'remote_user' using the ssh access command. Fill in the 'remote_user' and 
# 'server_ip_address' that corresponds to your actual info. ->
# # ~$ ssh remote_user@server_ip_address
# Enter your password when prompted.

# @ 14:32. Set up SSH key-based authentication so that you can log in to the server without a password. This is
# more secure and more convenient because it uses keys that can't be brute forced. It also allows log in without
# putting in a password every time, which is great for running remote scripts that connect to a web server. 
# NOTE: real-world application deployment involves setting up SSH keys and firewalls for proper precautions.

# @ 15:17. There's an easier way to copy keys with a command called "ssh-copy-id\
# remote_username@server_ip_address" 
# but this utility is not on all OS systems. SIDE NOTE: If the utility does not exist you can do a long command 
# to achieve what you need. ->
# # ~$ cat ~/.ssh/id_rsa.pub | ssh remote_username@server_ip_address "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat
# # \>>~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"

# @ 15:27. The following is the long way to do the above command. On your web server, create a directory in the
# home directory called ".ssh". 

# Now go to your local machine terminal and generate a pair of authentication keys with the following command ->
# # ~$ ssh-keygen -b 4096
# Enter a passphrase when prompted if you want to be more secure, but otherwise you can leave it empty. NOTE: if
# you create a passphrase at this point, you will be prompted to use it each time you try to log in to the web 
# server!

# @ 7:19. Notice that two new files have been made with a private and public key (id_rsa). The public key needs
# to be moved to the web server. This is done with the SCP (Secure Copy) command + the file path of id_rsa.pub +
# the ip_server_address. ->
# # ~$ scp ~/.ssh/id_rsa.pub remote_user@server_ip_address

# IF you want to copy to an exact location on the web server, then you put a colon after the address and specify 
# the directory. In this case it will be copied into a file called "authorized_keys" that will be auto created.
# Code Snippet. ->
# # ~$ scp ~/.ssh/id_rsa.pub remote_user@server_ip_address:~/.ssh/authorized_keys
# Enter the web server password when prompted

# @ 19:09. Switch to the web server terminal and navigate to the new ".ssh/authorized_keys" folder. You 
# should see the id_rsa.pub file there now.

# @ 19:43. Set some permissions for the .ssh directory to where the owner of the directory has RWX permissions 
# on the directory itself and the owner of the files in the directory will have RW permissions on the files. For
# the permissions on the directory, use the command ->
# # ~$ sudo chmod 700 ~/.ssh/
# Enter the password for this user when prompted. Now do a 600 command for all the files in the directory ->
# # ~$ sudo chmod 600 ~/.ssh/*

# @ 20:41. What the numbers in the 700 command mean are:
# 1st digit = 7 = Read/Write/Execute for the owner
# 2nd digit = 0 = No permissions for the group
# 3rd digit = 0 = No permissions for everyone else.

# What the numbers in the 600 command mean are:
# 1st digit = 6 = Read/Write for the owner
# 2nd digit = 0 = No permissions for the group
# 3rd digit = 0 = No permissions for everyone else.

# @ 21:15. To log out of the web server you type "exit" in the terminal. ->
# # ~$ exit
# Now to log back in, you run the same SSH Access command but this time there should be no prompt for a 
# passphrase ->
# # ~$ ssh remote_user@server_ip_address


# NOTE: If you had set up a passphrase during the generation of your local machine authentication keys, you will
# still be prompted for that passphrase regardless of the previous steps. If you want to remove the passphrase 
# to not have to use it everytime, use the following command that will decrypt the private key file and write it
# to a new temp file that will then need to be used to overwrite the original encrypted private key file. The 
# format of code is: "openssl rsa -in <Encrypted key filename> -out <Unencrypted key filename>". The encrypted 
# filename here is 'id_rsa'. So the command you use is ->
# # ~$ openssl rsa -in id_rsa -out id_rsa_un
# Open the 'id_rsa_un' file to verify it's been decrypted. Encrypted file headers have: 'Proc-Type:4,ENCRYPTED'. 
# Whereas unencrypted do NOT have that header.
# Now overwrite the original encrypted file and delete the temp unencrypted file ->
# # ~$ mv id_rsa_un id_rsa

# To encrypt the key again, use the same command & process but must specify an encryption algorithm for openssl
# to use and update file permissions. You can use aes128, aes192, aes256, camellia128, camellia192, camellia256, 
# des (avoid this one), des3 or idea. This example uses des3 ->
# # ~$ openssl rsa -des3 -in id_rsa -out id_rsa_en 
# Now overwrite the original unencrypted file and delete the temporarily made encrypted file ->
# # ~$ mv id_rsa_en id_rsa
# Update the file permissions ->
# # ~$ chmod 600 id_rsa


# @ 22:00. You need to disallow root logins over SSH while logged in as the user and not require password 
# authentication by updating the ssh_config file ->
# # ~$ sudo nano /etc/ssh/sshd_config
# You may be prompted for the web server user passphrase (this is not the same as your local machine ssh login!)
# Scroll thru the file and find "PermitRootLogin yes". Change it to "PermitRootLogin no". This user is now a 
# limited user that has sudo access, so there's no need to log in to the machine as root anymore.
# Continue scrolling and find a commented out line for "PasswordAuthentication yes". Uncomment it and change to 
# "PasswordAuthentication no". The reason for this is, now that the SSH keys are working, sometimes hackers try 
# to brute force a password and they can't get to one if we're not using one to log in and the SSH keys exist. 
# Save by typing in... ->
# # Ctrl + x
# # 'Y'
# # 'Enter'
# Restart the SSH service ->
# # ~$ sudo systemctl restart sshd

# @ 24:00. Setup an "uncomplicated firewall" ->
# # ~$ sudo apt install ufw
# Setup rules for the firewall ->
# # ~$ sudo ufw default allow outgoing
# # ~$ sudo ufw default deny incoming
# Now you want to configure allow rules for certain ports (22=SSH, HTTP, 5000) because if you leave the default
# that was just done, it can lock you out of your server unless you use explicit allow rules to access from the 
# outside of the server. Remember port 5000 is the port that flask development server runs on. ->
# # ~$ sudo ufw allow ssh
# # ~$ sudo ufw allow 5000
# Before going live, you want to test things. Don't allow port 80 or HTTP yet. Just enable the rules made above.
# Confirm 'y' when prompted. ->
# # ~$ sudo ufw enable

# @ 26:34. To see the status of things allowed & disallowed ->
# # ~$ sudo ufw status

# @ 26:48. Ready to deploy the flask application. First you need to get it on the web server. If it is in a git 
# repo, then you can clone it here into the server. If you're using an FTP, like Filezilla, then you can copy it
# over too. Since you're currently in a bash terminal, lets use that. Switch terminals to your local machine 
# now.

# @ 27:18. Before pushing the flask application to the server, and since your're using a virtual environment, 
# you'll want to create a requirements.txt file that captures all the dependencies needed to be installed for 
# the flask project to work. You should have used a virtual environment for the whole project; otherwise you'd 
# have to pip install everything that you used onto the server manually. 

# @ 28:00. Now activate the virtual environment for the flask app if it is not active already and navigate to 
# the flask app folder. Run pip freeze to see the list of installed dependencies and the exact versions for the
# packages. Code Snippet ->
# # ~$ pip freeze 
# To save all these requirements into a file called "requirements.txt" ->
# # ~$ pip freeze > requirements.txt

# @ 29:28. It's time to put the flask app on the web server using the SCP utility. To copy the entire directory
# you use -r which means recursively. You're copying from where your app folder is saved on your local machine 
# to your web server using your limited username and ip address with exact file location in that users home 
# folder. ->
# # ~$ scp -r Flask_Blog remote_user@server_ip_address:~/

# @ 31:12. Re-create the virtual environment on the remote_server to run the flask app in. You need to install
# some things first, like python3-pip ->
# # ~$ sudo apt install python3-pip
# You will be asked for the remote-server passphrase.

# @ 31:58. Now install python3 virtual environment library ->
# # ~$ sudo apt install python3-venv

# @ 32:18. Create a new virtual environment inside the flask project directory by specifying the Flask_Blog 
# directory and name the environment "venv". ->
# # ~$ python3 -m venv Flask_Blog/venv
# If you navigate into the Flask_blog folder you will see a new directory called "venv". To activate venv ->
# # ~$ source venv/bin/activate
# You will see "(venv)" appear before your terminal server name and file path listing.

# SIDE NOTE: If you are using conda you would go about this a different way since you can export your 
# environment with all the requirements in a file and then import all to re-create it elsewhere. To do this, 
# first install miniconda on the remote_server and source the .bashrc file to activate the installation. ->
# # ~$ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
# # ~$ bash Miniconda3-latest-Linux-x86_64.sh
# # ~$ source ~/.bashrc
# You should see "(base)" appear before the terminal ~$ now.
# Do not allow (base) environment to automatically activate for every instance of a terminal. Code Snippet. ->
# # ~$ conda config --set auto_activate_base false
# # ~$ source ~/.bashrc
# You will see the "(base)" disappear.
# Now import your exported "environment.yaml" file from within the Flask_Blog directory and call the new
# environment "flaskblog_env" just like it is on your local machine.
# # ~$ ~$ conda env create -f environment.yaml flaskblog_env
# Now activate the new environment. Code Snippet. ->
# # ~$ conda activate flaskblog_env
# The environment along with all the requirements needed for the flask application are now installed and ready
# to be launched.

# @ 33:29. With the venv environment activated, you can now install all of the requirements needed for the flask
# application to run. (only if you did not do the setup in the SIDE NOTE above). Make sure you are navigated 
# inside the Flask_Blog directory, then use the following command. Code Snippet. ->
# # ~$ pip install -r requirements.txt

# @ 34:04. The objective here is to test the website using the development server to make sure it works before 
# installing nginx and gUnicorn. There are a few variables that need to be set first for the secret key, 
# database URL, email user, and email password for password resets. These need to be set in order for the app
# to work properly. The local machine used environment variables, but you shouldn't do the same here because it
# can get tricky when working with different web servers. Instead, create a configuration file that holds all
# this sensitive information and load that into the application. Start by switching to your local machine CLI.

# @ 35:08. Activate your flask app environment. Grab the variables by using python. You can see which variables
# are needed by looking in the flask configuration file. Code Snippet. ->
# # ~$ python
# # >>> import os
# # >>> os.environ.get('SECRET_KEY')
# # 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
# # >>> os.environ.get('SQLALCHEMY_DATABASE_URI')
# # 'sqlite:///site.db'
# # >>> os.environ.get('EMAIL_USER')
# # 'user@address.com'
# # >>> os.environ.get('EMAIL_PASS')
# # 'password'
# # >>>

# @ 36:53. Now switch to the remote_server CLI and create a file called "flaskblog_config.json. It is named with 
# respect to the app it applies to so it can be differentiated from other possible config files for apps. But if
# it will be the only config file that lives on this server then it's ok to just call it config.json. If you're 
# more comfortable using yaml or the like, feel free to make it that type of file. Code Snippet. ->
# # ~$ sudo touch /etc/flaskblog_config.json
# Now edit that new file ->
# # ~$ sudo nano /etc/flaskblog_config.json
# Put the sensitive data in {} with comma separation for correct json syntax.->
# # {
# #     "SECRET_KEY": "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
# #     "SQLALCHEMY_DATABASE_URI": "sqlite:///site.db",
# #     "EMAIL_USER": "youremail",
# #     "EMAIL_PASS": "yourpassword"
# # }

# @ 39:57. Now that the config file has been setup and saved you need to edit the config.py file in the flask
# app to set those values. Remember you're still on the remote_server doing this alteration. Code Snippet. ->
# # ~$ sudo nano config.py
# Import json and load in the values. Note that when you use json.load on a json file, in python, it makes the 
# config variable a python dictionary which will be equal to all of the key value pairs form the json config 
# file. Code Snippet. ->
# # import json
# # 
# # with open('/etc/flaskblog_config.json') as config_file:
# #     config = json.load(config_file)

# @ 41:34. Once config is specified you will replace all the "os.environ.get" references to "config.get". ->
# # class Config:
# #       SECRET_KEY = config.get("SECRET_KEY")
# #       SQLALCHEMY_DATABASE_URI = config.get("SQLALCHEMY_DATABASE_URI")
# #       MAIL_USERNAME = config.get("EMAIL_USER")
# #       MAIL_PASSWORD = config.get("EMAIL_PASS")
# Save and exit the file.

# @ 42:25. Testing the app; there are several ways. When we tested on the local machine we used "python run.py".
# But if you "cat run.py" now, you will see that the command will do an "app.run(debug=True)". In this case we 
# want to set the host equal to 0.0.0.0 to expose the app to the outside world. Therefore, this time we will use
# "flask run" with an export of the flask project using a temporary environment variable. Code Snippet. ->
# # ~$ export FLASK_APP=run.py
# # ~$ flask run --host=0.0.0.0
# Now on your local machine go to your remote_server ip address at port 5000. Remember if you don't specify the
# exact port with the ip address then you won't see a page becuase port 80 is still blocked on the firewall. ->
# # server_ip_address:5000

# @ 44:48. Test the application by logging in and out with an existing user and then register a new user with
# credentials: "DeployedUser, DeployedUser@test.com, testing3". If it's successful then log in with this user 
# and create a new post. Try to update the same post and then delete the post. Then change the profile pic. 
# Logout and try to request password reset. (REMEMBER: in the flaskblog/users/utils.py file that the Password
# Reset Request sender=yourAcutalEmail) You should recieve and email with the reset link and be able to change
# the password to "testing4".

# @ 47:13. Everything is working fine, but you must realize that thus far it's all runing on a development 
# server (from python) on the live production server (remote_server). This is NOT what you want to do if you go 
# live. You don't want to send the http://0.0.0.0:5000 URL out using a development server. This server isn't
# made for high performance and to handle a lot of internet traffic. To do this, you use nginx and gUnicorn
# since that's what they're made for. So kill this server and proceed to install these items.

# @ 48:16. CD one folder level up into the home directory and install the following packages. (If you're using
# conda, then specify conda) ->
# # ~$ sudo apt install nginx
# # ~$ pip install gunicorn
# Change a few configurations to use these packages. Nginx is going to be the web server that will handle 
# requests in static files (CSS, JS, pictures); it's not handling python code. Python code is handled by 
# gunicorn. To do this, you need to delete the default nginx configuration file and create a new file. ->
# # ~$ sudo rm /etc/nginx/sites-enabled/default
# # ~$ sudo nano /etc/nginx/sites-enabled/flaskblog
# Put the following code into the new file that will specify port=80, server_name=server_ip_address,
# forward all static files by specifying their location in the static folder, forward all other traffic to 
# gunicorn (by default gunicorn runs on port 8000), pass all other extra variables for the proxy to gunicorn
# too, and turn redirect off. Code Snippet. ->
# # server {
# #         listen 80;
# #         server_name server_ip_address;
# # 
# #         location /static {
# #                 alias /home/username/Flask_Blog/flaskblog/static;
# #         }
# # 
# #         location / {
# #                 proxy_pass http://localhost:8000;
# #                 include /etc/nginx/proxy_params;
# #                 proxy_redirect off;
# #         }
# # }

# @ 54:03. Open up port 80 on the firewall because it is now being used in the configuration file of nginx.
# Also disallow traffic for port 5000 since we are done testing. Finally enable the settings ->
# # ~$ sudo ufw allow http/tcp
# # ~$ sudo ufw delete allow 5000
# # ~$ sudo ufw enable

# @ 54:49. restart nginx server. ->
# # ~$ sudo systemctl restart nginx
# Keep in mind that even though nginx is running, gunicorn is not. Verify this by opening an incognito browser
# and navigating to the server_name you have. You'll see an nginx error. But, you can still access static files
# if you manually navigate to them; input /static/main.css at the end of the server_name and you will see css.

# @ 56:35. Change directories into the flask app. You will need to run "workers" for guincorn. To determine how 
# many, the documentation for gunicorn says it should be (2 x num_cores) + 1. To see the number of cores on
# your machine for linux use the command ->
# # ~$ nproc --all
# In this case you will see 1. When applying that to the formula you get a number of 3.

# @ 58:13 Run gunicorn, the number of workers just determined, and specify the file that has the app (run.py) 
# with the following command ->
# # ~$ gunicorn -w 3 run:app
# You can run the same tests for functionality that were run before.

# @ 59:30. Things work, but you are manually running your server. You need something to auto-start and restart
# the server. Use software called supervisor to automate this function. ->
# # ~$ sudo apt install supervisor

# @ 1:00:05 Now setup a configuration file for supervisor. ->
# # ~$ sudo nano /etc/supervisor/conf.d/flaskblog.conf
# In the newly created file you will write the code to: give the program a name, the directory where the command
# will run from, the command to run using the full path to gunicorn (since you won't have the virtual 
# environment it's in activated yourself at the time), username, autostart, autorestart, stopasgroup, 
# killasgroup (to wrap up child processes), an error log, and an out log. Code Snippet. ->
# # [program:flaskblog]
# # directory=/home/username/Flask_Blog
# # command=/home/username/miniconda3/envs/flaskblog_env/bin/gunicorn -w 3 run:app
# # user=username
# # autostart=true
# # autorestart=true
# # stopasgroup=true
# # killasgroup=true
# # stderr_logfile=/var/log/flaskblog/flaskblog.err.log
# # stdout_logfile=/var/log/flaskblog/flaskblog.out.log

# @ 1:04:00. Create the directory that will hold the log files using -p to create any directory in the chain if 
# none exist. ->
# # ~$ sudo mkdir -p /var/log/flaskblog
# Create the log files specified earlier in the flaskblog.conf file ->
# # ~$ sudo touch /var/log/flaskblog/flaskblog.err.log
# # ~$ sudo touch /var/log/flaskblog/flaskblog.out.log

# @ 1:05:00. Restart the server to apply changes.
# # ~$ sudo supervisorctl reload

# @ 1:06:30. Some functionality is changed by the nginx server. If you try to upload a large photo you will get
# an error. Nginx limits uploads to 2MB. If you want to change this limit you can by altering the nginx
# configuration file. ->
# # ~$ sudo nano /etc/nginx/nginix.conf
# Scroll down to http section and add the line of code after types_hash_max_size to a size you want. Here it's
# 5 megabytes. Restart the nginx server. ->
# # client_max_body_size 5M;
# # ~$ sudo systemctl restart nginx
# If you go back to the browser and test by trying to upload a large file again, it will work. Remember that the
# large file size won't matter since the app will re-size it smaller no matter what.

# @ 1:09:00. Test that the password reset is still working just in case. You can reset the password from
# testing4 to testing3 on the DeployedUser account.

# @ 1:11:34. If you wanted to delete this server. Log in to your Linode account, find your server name, click
# the three dots displaying next to it, click on settings, towards the bottom of the page you will see Delete
# Linode. You can also just "Power Off" the server on linode to shut down the site until you need it.



########
# Part 14 - Custom Domain Name for the Application ->
# The process of buying a domain name to host the application. Register a domain name from Namecheap.com. Search
# for a domain name that is available, add it to your cart, and click on "View Cart".

# @ 3:15. In the cart you will see offers/options on duration of purchase per year and WhoisGuard. WhoisGuard is
# recommended because it protects your privacy with buying a domain. You enter a lot of personal info when
# buying a domain and if you don't use some type of protection then that info is available to people who try to
# look you up. If you open your CLI in linux and type in the command whois and the name of the domain you want
# to know, it will list out all the info. ->
# # ~$ whois <domain>
# WhoisGuard blocks the most personal info parts and lists only the registering site (in this case, namecheap).

# @ 5:29. Pay Now for your domain order. You don't need all the other add-ons. The payment shouldn't be more
# than $10. Once purchased, navigate to the Domain List to view your newly owned domain name. 

# @ 6:15. Now go to the linode site. You'll see in the dashboard the linodes you've made. Go to the "Get Help"
# area and do a search for DNS Manager. Follow the link provided and view the documentation on how to set-up a
# domain name. The link is -> https://www.linode.com/docs/platform/manager/dns-manager/
# Scroll down the page, you'll see the section "DNS Set-Up Checklist". You've done step 1; now on to step 2.

# @ 7:25. Click the link from step 2 and view the 5 linode server names. Copy them. Go to your Namecheap.com
# account and Paste the server names into your domain "Nameservers" area after clicking the "Manage" button for
# your domain. The linode server names are ->
# #     ns1.linode.com
# #     ns2.linode.com
# #     ns3.linode.com
# #     ns4.linode.com
# #     ns5.linode.com
# It will take a few hours for the change to take affect. While you're waiting you can move on to step 3.

# @ 10:03. Step 3 of the "DNS Set-Up Checklist" is add a domain, and then start adding some basic DNS records.
# Go back to the namecheap.com account and view the "Domains" area. There you will see a button to "Add a
# Domain"; click it. In the fields provided, fill in the info for Domain, email address, and optional tags.
# Click on create when done. 

# @ 11:38. Use the guide provided from the Linode site, below the checklist, to fill in the DNS records fields.
# You will be adding an "AAAA" record. Fill in the fields with the info of the flaskblog ip_servername.

# @ 13:45. Step 4, set the reverse DNS. The Linode site instructions may be outdated. Click on the section for
# "Linodes", then click on the "Networking" tab, and scroll down to the IPv4 section. Edit the "Reverse DNS" to
# be your domain name from namecheap. When you save you'll get an error. This is normal; changes take time to 
# take effect, about 15-30min. Once it works, test the website by navigating to it and clicking on the site to 
# verify functionality is good.



########
# Part 15 - How to enable HTTPS with a free SSL/TLS certificate using Let's Encrypt ->
# Secure your domain name with an SSL certificate. The icon of a lock on the browser window verifies if secured.
# @ 1:28. Go to the following website and click on "Get Started" -> https://letsencrypt.org/
# Look at the section for "With Shell Access" and click on the link for "Certbot" ACME client. On the certbot
# page, look for the area titled "My HTTP website is running:" and choose the web server and operating system 
# that you're using (for this flask series this would be Nginx and Ubuntu 18.10). 

# @ 2:07. Instructions will appear at the bottom of the page along with the commands needed to enter into your
# CLI. It's recommended to read through the documentation before continuing. Now SSH into your remote_server.
# To get a copy of the same commands used on the example video, go to this link. -> http://bit.ly/nginx-certbot

# @ 2:26. While logged into the remote_server, enter the commands in order as given to add Certbot PPA ->
# # ~$ sudo apt-get update
# # ~$ sudo apt-get install software-properties-common
# # ~$ sudo add-apt-repository universe
# # ~$ sudo add-apt-repository ppa:certbot/certbot
# # ~$ sudo apt-get update

# @ 4:23. Install Certbot
# # ~$ sudo apt-get install certbot python-certbot-nginx

# @ 4:33. Before running the next command, make a change to the nginx configuration file (made and located in
# /etc/nginx/sites-enabled/flaskblog). Currently the server_name is set as the ip_address; you want to instead 
# change that to be the new domain name you've set up. Open the nginx configuration in nano. ->
# # ~$ sudo nano /etc/nginx/sites-enabled/flaskblog
# Change the server_name to the domain name. Code Snippet. ->
# # server {
# #         listen 80;
# #         server_name www.yourwebsite.com;

# @ 5:50. Now get a certificate and have Certbot edit your Nginx configuration automatically to serve it,
# turning on HTTPS access in a single step. ->
# # ~$ sudo certbot --nginx
# When prompted, enter your email address, agree to terms, choose an option to share your email, and hit enter
# to activate all names in the list for HTTPS.

# @ 7:10. The CLI prompt will ask if you want to redirect HTTP traffic to HTTPS always or have both available.
# You want to not have both and always redirect to HTTPS; so choose option 2. You will see congratulations on
# successful enabling. Notice it reports that it changed the nginx configuration file you altered earlier.
# Cat into that file to see the changes. ->
# # ~$ cat /etc/nginx/sites-enabled/flaskblog
# You'll see code using port 443 ssl and redirects to certbot https. This is good. If there are issues with this
# automatic certbot command running, you could look into only getting the certificate only install and manually
# configuring. 

# @ 10:03. If you try to test nginx configuration it might appear to have an issue. For example, if you use the following command it will fail. That's to be expected because it's just a permission issue. ->
# # ~$ nginx -t
# If you run the command using sudo then you shouldn't have that problem ->
# # ~$ sudo nginx -t

# @ 10:53. Allow HTTPS traffic to your website. You can disallow HTTP traffic if you want, but certbot will 
# automatically redirect traffic to there anyway, so it's not necessary. Once you've made the changes, make
# sure to restart your server for them to take affect. Alter the firewall settings. ->
# # ~$ sudo ufw allow https
# # ~$ sudo systemctl restart nginx

# @ 11:37. Test your website. If you already had it up, reload it and take note of the change in the website
# that should show a lock icon and https: added to the address. The site is now secure for private info and 
# credit card numbers. Test the overall site functionality to verify that all pages include the browser lock
# icon.

# @ 12:53. Certificates last about 90 days and need to be renewed. It's best to set up automatic renewal.
# The Certbot packages on your system come with a cron job or systemd timer that will renew your certificates 
# automatically before they expire. You will not need to run Certbot again, unless you change your 
# configuration. You can test automatic renewal for your certificates by running this command ->
# # ~$ sudo certbot renew --dry-run

# @ 14:09. If you want to edit the crontab, do that with sudo, so that the commands run are run as root. ->
# # ~$ sudo crontab -e
# When prompted select an editor. Lets say you want to renew a certificate at 4:30am on the 1st of every month.
# The below code will do this. The asterisk for month means every month. Asterisk for day of week means any day
# no matter which is the 1st. The --quiet is to perform the command in the background.
# min. hrs  dayOfMonth month dayOfWeek   command            
# 30    4    1           *    *          sudo cerbot renew --quiet
# ->
# # ~$ 30 4 1 * * sudo cerbot renew --quiet

THE END